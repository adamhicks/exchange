package orders

// Code generated by glean from glean.go:5. DO NOT EDIT.

import (
	"context"
	"database/sql"
	"time"
)

const cols = " `id`, `type`, `is_buy`, `status`, `limit_volume`, `limit_price`, `market_base`, `market_counter`, `created_at`, `updated_at`, `update_seq` "
const selectPrefix = "select " + cols + " from orders where "

var _ time.Time

func Lookup(ctx context.Context, dbc dbc, id int64) (*Order, error) {
	return lookupWhere(ctx, dbc, "id=?", id)
}

// lookupWhere queries the orders table with the provided where clause, then scans
// and returns a single row.
func lookupWhere(ctx context.Context, dbc dbc, where string, args ...interface{}) (*Order, error) {
	return scan(dbc.QueryRowContext(ctx, selectPrefix+where, args...))
}

// scanWhere queries the orders table with the provided where clause and
// calls callback with the results one row at a time.
//
// An intermediate buffered channel is introduced between the internal callback
// and the provided callback. This allows testing (with only a single DB connection)
// if the number of rows fits in the buffer (< 100).
func scanWhere(in context.Context, dbc *sql.DB, fn func(*Order) error,
	where string, args ...interface{}) error {

	// If the reader errors, we need to cancel the streamer.
	ctx, cancel := context.WithCancel(in)
	defer func() {
		// Testing work around: allow scanWhere to return before we cancel the context.
		// See src/bitx/db/db_test.go:TestCtxCancelIssue.
		time.Sleep(time.Millisecond)
		cancel()
	}()

	// Note: tests will block if scanning more than 100 rows.
	ch := make(chan *Order, 100)

	fn2 := func(i *Order) error {
		ch <- i
		return nil
	}

	// Start streamer, from DB into the channel.
	var scanErr error
	go func() {
		// When the streamer is done, close the channel for the reader to return.
		defer close(ch)
		scanErr = innerScanWhere(ctx, dbc, fn2, where, args...)
	}()

	// Start reader, from the channel until closed or error.
	for i := range ch {
		if err := fn(i); err != nil {
			return err
		}
	}

	return scanErr
}

func innerScanWhere(ctx context.Context, dbc dbc, f func(*Order) error,
	where string, args ...interface{}) error {

	rows, err := dbc.QueryContext(ctx, selectPrefix+where, args...)
	if err != nil {
		return err
	}
	defer rows.Close()

	for rows.Next() {
		r, err := scan(rows)
		if err != nil {
			return err
		}
		err = f(r)
		if err != nil {
			return err
		}
	}
	return rows.Err()
}

// listWhere queries the orders table with the provided where clause, then scans
// and returns all the rows.
func listWhere(ctx context.Context, dbc dbc, where string, args ...interface{}) ([]Order, error) {

	rows, err := dbc.QueryContext(ctx, selectPrefix+where, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var res []Order
	for rows.Next() {
		r, err := scan(rows)
		if err != nil {
			return nil, err
		}
		res = append(res, *r)
	}

	return res, rows.Err()
}

func scan(row row) (*Order, error) {
	var g glean

	err := row.Scan(&g.ID, &g.Type, &g.IsBuy, &g.Status, &g.LimitVolume, &g.LimitPrice, &g.MarketBase, &g.MarketCounter, &g.CreatedAt, &g.UpdatedAt, &g.UpdateSeq)
	if err != nil {
		return nil, err
	}

	return &Order{
		ID:            g.ID,
		Type:          g.Type,
		IsBuy:         g.IsBuy,
		Status:        g.Status,
		LimitVolume:   g.LimitVolume,
		LimitPrice:    g.LimitPrice,
		MarketBase:    g.MarketBase,
		MarketCounter: g.MarketCounter,
		CreatedAt:     g.CreatedAt,
		UpdatedAt:     g.UpdatedAt,
		UpdateSeq:     g.UpdateSeq.Int64,
	}, nil
}

// dbc is a common interface for *sql.DB and *sql.Tx.
type dbc interface {
	QueryContext(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error)
	QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

// row is a common interface for *sql.Rows and *sql.Row.
type row interface {
	Scan(dest ...interface{}) error
}
